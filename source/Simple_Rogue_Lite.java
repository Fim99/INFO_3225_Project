/* autogenerated by Processing revision 1293 on 2024-04-17 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Simple_Rogue_Lite extends PApplet {

Player player;
Button start_button, main_button, leaderboard_button, quit_button, select_button_1, select_button_2, select_button_3;
int score = 0, wave = 0;
float total_defeated, total_experience, difficulty = 1;
boolean display_hitbox = false, is_paused = false, is_dead = false, is_selecting = false, is_reset = false, is_invincible = false;
String current_screen;
String[] random_stat;
ArrayList<Enemy> arena_enemies = new ArrayList<Enemy>();
ArrayList<Player_Projectile> player_projectiles = new ArrayList<Player_Projectile>();
PFont font;
PImage background, death_effect_image;
Table table;

PImage player_image, player_projectile_image, 
basic_left_image, basic_right_image, 
advanced_left_image, advanced_right_image, 
speeder_left_image, speeder_right_image, 
giant_left_image, giant_right_image;


// Explain the point of the game
// Explain the scribble theme
// Explain HUD
// Show random level up, and how stats work
// Show all enemies such as boss and effects
// Show maxed out player and how difficulty works
// Show command keys 
// Show leaderboard
// Explain leaderboard sort
// Explain code

public void setup()
{
  // Initial Setup
  frameRate(60);
  /* size commented out by preprocessor */;
  background(125);
  noStroke();

  // Load font and background, set current screen to "MAIN SCREEN"
  font = createFont("PipersPlayroom.ttf", 128);
  textFont(font);
  background = loadImage("paper.jpg");
  
  // Load Effects
  death_effect_image = loadImage("Death_Effect.png");
  
  // Load Sprites
  player_image = loadImage("Player.png");
  player_projectile_image = loadImage("Player-Projectile.png");
  basic_left_image = loadImage("Basic-Left.png");
  basic_right_image = loadImage("Basic-Right.png");
  advanced_left_image = loadImage("Advanced-Left.png");
  advanced_right_image = loadImage("Advanced-Right.png"); 
  speeder_left_image = loadImage("Speeder-Left.png");
  speeder_right_image = loadImage("Speeder-Right.png");
  giant_left_image = loadImage("Giant-Left.png");
  giant_right_image = loadImage("Giant-Right.png");
  
  // set current screen to "MAIN SCREEN"
  current_screen = "MAIN SCREEN";
  
  // load leaderboard table
  table = loadTable("data/leaderboard.csv", "header");

  // Create new player
  player = new Player();

  // Create Buttons
  start_button = new Button();
  leaderboard_button = new Button();
  main_button = new Button();
  quit_button = new Button();
}

// draw screen based of current_screen 
public void draw()
{
  switch(current_screen)
  {
  case "MAIN SCREEN":
    if (!is_reset)
    {
      reset_game();
      reset_buttons();
    }
    draw_main_screen();
    break;

  case "GAME SCREEN":
    if (!is_reset)
    {
      reset_game();
      reset_buttons();
    }
    draw_game_screen();
    break;

  case "LEADERBOARD SCREEN":
    if (!is_reset)
    {
      reset_game();
      reset_buttons();
      sort_leaderboard();
    }
    draw_leaderboard_screen();
    break;

  case "DEATH SCREEN":
    if (is_dead)
    {
      draw_death_screen();
    }
    break;
  }
}

public void draw_game_screen()
{
  background(background);

  difficulty_logic();
  enemy_updates();
  projectile_updates();
  player_updates();
  player.display_stats();

  // If player is selecting, draw selection buttons and pause
  if (is_selecting && !is_dead)
  {
    is_paused = true;

    // Info text
    textAlign(CENTER, CENTER);
    fill(0);
    textSize(20);
    text("CHOOSE A STAT TO INCREASE", width / 2, height / 2 - 125);
    textSize(60);
    text("LEVEL UP", width / 2, height / 2 - 200);

    // Buttons for selections and display()
    select_button_1 = new Button(width / 2 - 150, height / 2 - 75, 300, 50, color(0, 0, 0, 150), color(255), random_stat[0]);
    select_button_2 = new Button(width / 2 - 150, height / 2, 300, 50, color(0, 0, 0, 150), color(255), random_stat[1]);
    select_button_3 = new Button(width / 2  -150, height / 2 + 75, 300, 50, color(0, 0, 0, 150), color(255), random_stat[2]);

    select_button_1.display();
    select_button_2.display();
    select_button_3.display();
  }

  // --- Display score and dead / paused ---
  if (is_dead)
  {
    player.health = 0;
    is_paused = true;
    current_screen = "DEATH SCREEN";
  }

  if (is_paused && !is_dead && !is_selecting)
  {
    textSize(70);
    textAlign(CENTER, CENTER);
    fill(0);
    text("PAUSED", width / 2, height / 2);
  }

  textSize(25);
  textAlign(CENTER, CENTER);
  fill(0);
  text("SCORE: " + score, width / 2, 50);
}

// Draw main screen
public void draw_main_screen()
{
  textSize(70);
  textAlign(CENTER, CENTER);
  background(background);
  fill(0);
  text("SCRIBBLE SURVIVAL", width / 2, height / 2 - 150);

  // Create Button's
  // Button(x, y, button_width, button_height, background_color, text_color, label)
  start_button = new Button(width / 2 - 100, height / 2 - 75, 200, 50, color(0, 0, 0, 150), color(255), "START GAME");
  leaderboard_button = new Button(width / 2 - 100, height / 2, 200, 50, color(0, 0, 0, 150), color(255), "LEADERBOARD");
  quit_button = new Button(width / 2 - 100, height / 2 + 75, 200, 50, color(0, 0, 0, 150), color(255), "QUIT");

  start_button.display();
  leaderboard_button.display();
  quit_button.display();
}

// Draw death screen
public void draw_death_screen()
{
  textSize(70);
  textAlign(CENTER, CENTER);
  fill(125, 0, 0);
  text("DEAD", width / 2, height / 2 - 150);

  // Create Button's
  // Button(x, y, button_width, button_height, background_color, text_color, label)
  start_button = new Button(width / 2 - 100, height / 2 - 75, 200, 50, color(120, 0, 0, 255), color(255), "PLAY AGAIN");
  main_button = new Button(width / 2 - 100, height / 2, 200, 50, color(120, 0, 0, 255), color(255), "MAIN MENU");
  leaderboard_button = new Button(width / 2 - 100, height / 2 + 75, 200, 50, color(120, 0, 0, 255), color(255), "LEADERBOARD");

  start_button.display();
  main_button.display();
  leaderboard_button.display();
}

public void draw_leaderboard_screen()
{
  textSize(70);
  textAlign(CENTER, CENTER);
  background(background);
  fill(0);
  text("LEADERBOARD", width / 2, height / 2 - 360);
  
  // Load leaderboard.csv table
  table = loadTable("data/leaderboard.csv", "header");
  
  float start_y = 100; 
  float row_height = 50;
  int count = 1;
  
  //println(table.getRowCount() + " total rows in table");
  for (TableRow row : table.rows()) 
  {
    float leaderboard_score = row.getFloat("Score");
    float leaderboard_defeated = row.getFloat("Defeated");
    float leaderboard_experience = row.getFloat("Experience");
    
    // Display top 3 as gold, silver, bronze
    if (count == 1)
    {
      fill(200, 200, 0, 200);
    }
    else if (count == 2)
    {
      fill(150, 150, 130, 200);
    }
    else if (count == 3)
    {
      fill(160, 80, 0, 200);
    }
    else
    {
      fill(0, 0, 0, 150);
    }
    
    // Display row on screen
    rectMode(CENTER);
    rect(width / 2, start_y, 400, row_height - 15);
    
    fill(255);
    textSize(24);
    textAlign(CENTER, CENTER);
    text(count + ". Score: " + (int) leaderboard_score + ", Defeated: " + (int) leaderboard_defeated + ", Experience: " + (int) leaderboard_experience, width / 2, start_y);
    
    // Increment start_y for next row and count
    start_y += row_height;
    count += 1;
  }
  
  // Call search leaderboard method
  search_leaderboard_by_defeated();

  // Create Button's
  // Button(x, y, button_width, button_height, background_color, text_color, label)
  start_button = new Button(width / 2 - 100, height / 2 + 250, 200, 50, color(0, 0, 0, 150), color(255), "START GAME");
  main_button = new Button(width / 2 - 100, height / 2 + 325, 200, 50, color(0, 0, 0, 150), color(255), "MAIN MENU");

  start_button.display();
  main_button.display();
}

// --- Logic for difficulty increase ---
public void difficulty_logic() 
{
  // Increase difficulty based on level
  difficulty = player.level / 1.5f;
    
  // Check if the arena is empty
  if (arena_enemies.isEmpty()) 
  {
    wave += 1;
    // Add Basic enemies based on difficulty
    for (int i = 0; i < 2 * difficulty; i++) 
    {
      arena_enemies.add(new Basic());
    }
    
    // Add Advanced enemies based on difficulty
    for (int i = 0; i < 1 * difficulty; i++) 
    {
      arena_enemies.add(new Advanced());
    }
    
    // Add Advanced enemies based on difficulty
    for (int i = 0; i < 1 * difficulty; i++) 
    {
      arena_enemies.add(new Speeder());
    }
    
    if (wave % 10 == 0)
    {
      arena_enemies.add(new Giant());
    }
    
  }
}

// --- Do updates for each enemy ---
public void enemy_updates()
{
  ArrayList<Enemy> enemies_to_remove = new ArrayList<>();
  for (int i = arena_enemies.size() - 1; i >= 0; i--)
  {
    Enemy enemy = arena_enemies.get(i);
    enemy.display();
    if (display_hitbox)
    {
      enemy.display_hitbox();
    }
    enemy.update(player);

    // Check player projectile collision with enemies
    for (int j = player_projectiles.size() - 1; j >= 0; j--)
    {
      Player_Projectile projectile = player_projectiles.get(j);
      if (projectile.collision(enemy))
      {
        // Take damage and remove projectile and enemy if collision detected
        player_projectiles.remove(j);
        enemy.take_damage(projectile);
        start_hit_effect(enemy.x, enemy.y, 5);
        if (enemy.health <= 0)
        {
          // Add enemy to array if health is depleted
          enemies_to_remove.add(enemy);
        }
        break;
      }
    }

    // Add the enemy to ArrayList collided with
    if (player.collision(enemy))
    {
      // Take damage and remove enemy if collision is detected
      if(!is_invincible)
      {
        player.take_damage(enemy);
      }
      start_hit_effect(enemy.x, enemy.y, 5);
      enemies_to_remove.add(enemy);
    }
  }
  // Loop through ArrayList to remove enemy and call required methods 
  for (Enemy enemy : enemies_to_remove) 
  {
    total_defeated += 1;
    start_death_effect(enemy.x, enemy.y);
    enemy.give_experience(player);
    enemy.give_score_increase();
    arena_enemies.remove(enemy);
  }
}

// --- Do updates for each player projectile and check for click using player.shoot() ---
public void projectile_updates()
{
  player.shoot();
  for (int i = player_projectiles.size() - 1; i >= 0; i--)
  {
    Player_Projectile projectile = player_projectiles.get(i);
    projectile.display();
    if (display_hitbox)
    {
      projectile.display_hitbox();
    }
    projectile.update();

    // Check if the player projectile hits the screen edges
    if (projectile.x < 0 ||projectile.x > width || projectile.y < 0 || projectile.y > height)
    {
      player_projectiles.remove(i);
    }
  }
}

// --- Do updates for player ---
public void player_updates()
{
  player.display();
  if (display_hitbox)
  {
    player.display_hitbox();
  }
  player.update();
  player.check_regen();
  update_effects();

  if (player.check_level_up() && !is_dead)
  {
    is_selecting =  true;
    random_stat = player.random_stat();
  }

  if (player.health <= 0)
  {
    save_score(score);
    is_dead = true;
  }
}

// Reset game
public void reset_game()
{
  score = 0;
  wave = 0;
  total_defeated = 0;
  total_experience = 0;
  difficulty = 0;
  display_hitbox = false;
  is_paused = false;
  is_dead = false;
  is_selecting = false;
  is_invincible = false;
  arena_enemies.clear();
  player_projectiles.clear();
  player.reset_player();
  effects.clear();
  is_reset = true;
}

// Save current runs score into leaderboard.cvs 
public void save_score(int score)
{
  TableRow new_row = table.addRow();
  new_row.setFloat("Score", score);
  new_row.setFloat("Defeated", total_defeated);
  new_row.setFloat("Experience", total_experience);
  saveTable(table, "data/leaderboard.csv");
  
  // Call sort_scoreboard() method
  sort_leaderboard();
}

// Method to sort and cull leaderboard
public void sort_leaderboard() 
{
  int row_count = table.getRowCount();

  // Bubble sort algorithm to sort the leaderboard by score in descending order
  for (int i = 0; i < row_count - 1; i++) 
  {
    for (int j = 0; j < row_count - i - 1; j++) 
    {
      TableRow row_1 = table.getRow(j);
      TableRow row_2 = table.getRow(j + 1);

      float score_1 = row_1.getFloat("Score");
      float score_2 = row_2.getFloat("Score");

      if (score_1 < score_2) 
      {
        // Swap row data
        float temp_score = row_1.getFloat("Score");
        float temp_defeated = row_1.getFloat("Defeated");
        float temp_experience = row_1.getFloat("Experience");

        row_1.setFloat("Score", row_2.getFloat("Score"));
        row_1.setFloat("Defeated", row_2.getFloat("Defeated"));
        row_1.setFloat("Experience", row_2.getFloat("Experience"));

        row_2.setFloat("Score", temp_score);
        row_2.setFloat("Defeated", temp_defeated);
        row_2.setFloat("Experience", temp_experience);
      }
    }
  }
  
  // Remove excess rows if there are more than 10 rows, keep leaderboard as top 10 scores
  while (table.getRowCount() > 10) 
  {
    table.removeRow(table.getRowCount() - 1);
  }
  
  // Save the sorted table back to the csv file
  saveTable(table, "data/leaderboard.csv");
}

// Method to search and display the leaderboard row with the most Experience
public void search_leaderboard_by_defeated() 
{
  // Initialize the index of the row with the highest Defeated value
  int highest_defeated_index = 0; 
  float highest_defeated = 0; 
  
  // Iterate through each row in the leaderboard table
  for (int i = 0; i < table.getRowCount(); i++) 
  {
    TableRow row = table.getRow(i);
    
    // Get the Defeated value from the current row
    float defeated = row.getFloat("Defeated");
    
    // Check if the Defeated value of the current row is higher than the current highest Defeated
    if (defeated > highest_defeated) 
    {
      highest_defeated = defeated;
      highest_defeated_index = i;
    }
  }
  
  // Display row on screen
  fill(150, 0, 0, 150);   
  rectMode(CENTER);
  rect(width / 2, height / 2 + 210, 450, 30);
  
  fill(255);
  textSize(24);
  textAlign(CENTER, CENTER);
  
  // Display the row with the highest Defeated
  if (highest_defeated_index != -1) 
  {
    TableRow highest_defeated_row = table.getRow(highest_defeated_index);
    float score = highest_defeated_row.getFloat("Score");
    float defeated = highest_defeated_row.getFloat("Defeated");
    float experience = highest_defeated_row.getFloat("Experience");
    
    text("Most defeated enemies in a run is: " + (int) defeated, width / 2, height / 2 + 210);
  } 
  else 
  {
    text("None Defeated", width / 2, height / 2 + 210);
  }
}

// Reset Buttons
public void reset_buttons()
{
  start_button = null;
  leaderboard_button = null;
  main_button = null;
  quit_button = null;

  start_button = new Button();
  main_button = new Button();
  leaderboard_button = new Button();
  quit_button = new Button();
}

// Check for if button is pressed
public void mousePressed()
{
  if (current_screen != "GAME SCREEN")
  {
    if (start_button.is_clicked())
    {
      //println("Start Screen Clicked");
      current_screen = "GAME SCREEN";
      is_reset = false;
    }
    if (main_button.is_clicked())
    {
      //println("Main Screen Clicked");
      current_screen = "MAIN SCREEN";
      is_reset = false;
    }
    if (leaderboard_button.is_clicked())
    {
      //println("Leaderboard Screen Clicked");
      current_screen = "LEADERBOARD SCREEN";
      is_reset = false;
    }
    if (quit_button.is_clicked())
    {
      exit();
    }
  }

  if (!is_dead && current_screen == "GAME SCREEN" && is_selecting)
  {
    if (select_button_1.is_clicked())
    {
      player.increase_stat(random_stat[0]);
      is_selecting = false;
      is_paused = false;
    }
    if (select_button_2.is_clicked())
    {
      player.increase_stat(random_stat[1]);
      is_selecting = false;
      is_paused = false;
    }
    if (select_button_3.is_clicked())
    {
      player.increase_stat(random_stat[2]);
      is_selecting = false;
      is_paused = false;
    }
  }
}

// check for key presses
public void keyPressed()
{
  player.keyPressed();

  switch(key)
  {
    // Clear Enemy array
  case 'c':
    arena_enemies.clear();
    break;

    // Disable player death check
  case 'i':
    is_invincible = !is_invincible;
    break;

    // Display Hitboxes
  case 'h':
    display_hitbox = !display_hitbox;
    break;

    // Give player experience for current level
  case 'l':
    player.experience = player.max_experience;
    break;

    // Pause game
  case 'p':
    is_paused = !is_paused;
    break;

    // Reset game
  case 'r':
    reset_game();
    break;
   
    // Make max experience very high
  case 'e':
    player.max_experience = 10000000;
    break;

    // Kill Player
  case 'k':
    player.health = -100;
    is_dead = true;
    break;
    
    // Max player stats (give 100)
  case 'm':
    for (int i = 0; i < 100; i++)
    {
      player.increase_stat("MAX HEALTH");
      player.increase_stat("REGEN");
      player.increase_stat("DAMAGE");
      player.increase_stat("SPEED");
      player.increase_stat("PROJECTILE SPEED");
      player.increase_stat("FIRERATE");
      player.level += 1;
    }
    break;
  }
}

public void keyReleased()
{
  player.keyReleased();
}
class Advanced extends Enemy
{
  // Basic constructor 
  Advanced(float x, float y, float hitbox_length, float hitbox_width, float health ,float damage, float speed, float experience_drop, float score_increase)
  {
    super(x, y, hitbox_length, hitbox_width, health, damage, speed, experience_drop, score_increase);
  }
  
  // Basic constructor with default values
  Advanced()
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed, experience_drop, score_increase)
    super(random(width), random(height), 50, 50, 3, 2, 0.75f, 5, 20);
  }
   
  public void display() 
  {
    super.display();
    fill(50, 200, 0);
    //circle(x, y, 25);
    
    imageMode(CENTER);
    if(facing_left)
    {
      image(advanced_left_image, x, y, 50, 50);
    }
    else if(facing_right)
    {
      image(advanced_right_image, x, y, 50, 50); 
    }
  }
}
class Basic extends Enemy
{
  // Basic constructor 
  Basic(float x, float y, float hitbox_length, float hitbox_width, float health ,float damage, float speed, float experience_drop, float score_increase)
  {
    super(x, y, hitbox_length, hitbox_width, health, damage, speed, experience_drop, score_increase);
  }
  
  // Basic constructor with default values
  Basic()
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed, experience_drop, score_increase)
    super(random(width), random(height), 50, 50, 1, 1, 0.5f, 2, 10);
  }
   
  public void display() 
  {
    super.display();
    fill(0, 100, 200);
    //circle(x, y, 25);
    
    imageMode(CENTER);
    if(facing_left)
    {
      image(basic_left_image, x, y, 50, 50);
    }
    else if(facing_right)
    {
      image(basic_right_image, x, y, 50, 50); 
    }
  }
}
abstract class Boss extends Enemy 
{
  float max_health;
  String name;
  int lastSpawnTime;

  // Boss constructor 
  Boss(float x, float y, float hitbox_length, float hitbox_width, float health, float damage, float speed, float experience_drop, float score_increase, String name) 
  {
      super(x, y, hitbox_length, hitbox_width, health, damage, speed, experience_drop, score_increase);
      this.max_health = health;
      this.name = name;
      lastSpawnTime = millis();
  }

  // Boss constructor with default values
  Boss() 
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed, experience_drop, score_increase)
    super(random(width), random(height), 50, 50, 100, 100, 0.4f, 50, 500);
    name = "BOSS";
    lastSpawnTime = millis();
  }

  public void boss_spawn_enemy() 
  {
    // Check if specified time have passed since the last spawn
    if (millis() - lastSpawnTime >= 2500) 
    {
      // Spawn a new enemy
      arena_enemies.add(new Speeder(x, y));
      // Update lastSpawnTime
      lastSpawnTime = millis();
    }
  }

  public void boss_health() 
  {
    // Display boss health bar
    float boss_health = 450 * (health / max_health);

    pushMatrix();
    rectMode(CORNER);
    fill(0);
    rect(width / 2 - 225, height - 30, 450, 20);
    fill(250, 120, 10);
    rect(width / 2 - 225, height - 30, boss_health, 20);
    popMatrix();
    fill(255);
    textSize(20);
    textAlign(CENTER, CENTER);
    text((int)health, width / 2 - 200, height - 20);
    text(name, width / 2, height - 20);
    text((int)max_health, width / 2 + 200, height - 20); 
  }

  public void display() 
  {
    boss_health();
    
    // Call boss_spawn_enemy method
    boss_spawn_enemy();
  }
}
class Button 
{
  // Initialize Variables
  float x, y, button_width, button_height; 
  String label;
  int default_background_color, hover_background_color, text_color;
  boolean clicked;

  // Button Constructor
  Button(float x, float y, float button_width, float button_height, int default_background_color, int text_color, String label) 
  {
    this.x = x;
    this.y = y;
    this.button_width = button_width;
    this.button_height = button_height;
    this.default_background_color = default_background_color;
    this.hover_background_color = darker_color(default_background_color);
    this.text_color = text_color;
    this.label = label;
    this.clicked = false;
  }
  
  Button() 
  {
    this(0, 0, 0, 0, color(0, 0, 0, 150), color(255), "BUTTON");
  }
  
  // Check if the button is clicked
  public boolean is_clicked() 
  {
    return mouseX > x && mouseX < x + button_width && mouseY > y && mouseY < y + button_height;
  }
  
  // Check if the mouse is hovering over the button
  public boolean is_hovering() 
  {
    return mouseX > x && mouseX < x + button_width && mouseY > y && mouseY < y + button_height;
  }

  // Method to calculate a darker version of a color
  public int darker_color(int c) 
  {
    float factor = 50;
    float r = red(c) + factor;
    float g = green(c) + factor;
    float b = blue(c) + factor;
    return color(r, g, b);
  }

  // Display Button
  public void display() 
  { 
    textSize(25);
    textAlign(CENTER, CENTER);
    
    if (is_hovering()) 
    {
      fill(hover_background_color);
    } 
    else 
    {
      fill(default_background_color);
    }
    
    rectMode(CORNER);
    rect(x, y, button_width, button_height);
    fill(text_color);
    text(label, x + button_width / 2, y + button_height / 2);
  }
}
class Death_Effect extends Effect 
{
  // Initialize variables
  float rotation;

  Death_Effect(float x, float y, int duration) 
  {
    super(x, y, duration);
    this.rotation = random(TWO_PI);
  }

  // Display method for Death Effect
  public void display() 
  {
    imageMode(CENTER);
    pushMatrix();
    translate(x, y);
    rotate(rotation);
    image(death_effect_image, 0, 0, 50, 50); 
    popMatrix();
  }
}

// Method to start a new death effect
public void start_death_effect(float x, float y) 
{
  effects.add(new Death_Effect(x, y, 150));
}
// ArrayList to hold effects
ArrayList<Effect> effects = new ArrayList<Effect>();

// Abstract class to represent an effect
abstract class Effect implements Display 
{
  float x, y;
  int start_time;
  int duration;
  
  Effect(float x, float y, int duration) 
  {
    this.x = x;
    this.y = y;
    this.duration = duration;
    this.start_time = millis();
  }
  
  public boolean is_active() 
  {
    return millis() - start_time < duration;
  }
}

public void update_effects() 
{
  for (int i = effects.size() - 1; i >= 0; i--) 
  {
    Effect effect = effects.get(i);
    
    // Draw the effect at the given position for each instance
    if (effect instanceof Death_Effect) 
    {
      Death_Effect death_effect = (Death_Effect) effect;
      death_effect.display();
    }
    else if (effect instanceof Hit_Effect)
    {
      Hit_Effect hit_effect = (Hit_Effect) effect;
      hit_effect.display();
    }
    
    // Check if the effect duration has passed
    if (!effect.is_active()) 
    {
      effects.remove(i);
    }
  }
}
abstract class Enemy extends Entity
{
  float experience_drop, score_increase;
  
  Enemy(float x, float y, float hitbox_length, float hitbox_width, float health ,float damage, float speed, float experience_drop, float score_increase)
  {
    super(x, y,  hitbox_length, hitbox_width, health, damage, speed);
    this.experience_drop = experience_drop;
    this.score_increase = score_increase;
  }
  
  Enemy()
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed)
    super(random(width), random(height), 25, 25, 3, 1, 1);
    this.experience_drop = 1;
    this.score_increase = 1;
  }
  
  // give experience to player
  public void give_experience(Player player)
  {
    player.experience += experience_drop;
    total_experience += experience_drop;
  }
  
  public void give_score_increase()
  {
    score += score_increase;
  }

  // Method to move the enemy towards the player
  public void update(Player player) 
  {
    if(!is_paused)
    {
      // Calculate direction vector from the enemy to the player
      PVector direction = new PVector(player.x - x, player.y - y).normalize();
      
      // Adjust enemy's position based on the direction vector and enemy's speed
      float add_x = direction.x * speed;
      float add_y = direction.y * speed;
      
      move(add_x, add_y);
    }
  }
}
abstract class Entity implements Moveable, Display 
{
  // Initilaize variables for all objects of type Entity
  float x, y, add_x, add_y, prev_x, health, damage, speed, hitbox_length, hitbox_width;
  boolean facing_left = false, facing_right = true;
  
  // Entity Constructor
  Entity(float x, float y, float hitbox_length, float hitbox_width, float health ,float damage, float speed)
  {
    this.x = x;
    this.y = y;
    this.hitbox_length = hitbox_length;
    this.hitbox_width = hitbox_width;
    this.health = health;
    this.damage = damage;
    this.speed = speed;
  }
  
  // Entity Constructor with default values
  Entity()
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed)
    this(width / 2, height / 2, 25, 25, 25, 1, 1);
  }
  
  // move method for all entities, add_x and add_y are added to the entity's current coords
 public void move(float add_x, float add_y)
  {
    this.add_x = add_x;
    this.add_y = add_y;
    
    // Store the previous x position
    prev_x = x;
    
    this.x = x + add_x;
    this.y = y + add_y;
    
    // Update facing direction based on movement
    if (x < prev_x) 
    {
      facing_left = true;
      facing_right = false;
    } 
    else if (x > prev_x) 
    {
      facing_left = false;
      facing_right = true;
    }
  }
  
  // collision detection method used to determine if two entities have collided
  public boolean collision(Entity other) 
  {
    // Calculate bounding box coordinates for both entities
    float left1 = x - hitbox_length / 2;
    float right1 = x + hitbox_length / 2;
    float top1 = y - hitbox_width / 2;
    float bottom1 = y + hitbox_width / 2;
  
    float left2 = other.x - other.hitbox_length / 2;
    float right2 = other.x + other.hitbox_length / 2;
    float top2 = other.y - other.hitbox_width / 2;
    float bottom2 = other.y + other.hitbox_width / 2;
   
    // Check for collision using AABB collision detection
    if (left1 < right2 && right1 > left2 && top1 < bottom2 && bottom1 > top2) 
    {
        return true;
    } 
    else 
    {
        return false;
    }
  }
  
  public void take_damage(Entity other)
  {
    health = health - other.damage;
  }
  
  // display hitbox for entity
  public void display_hitbox() 
  {
    // Calculate bounding box coordinates for the entity
    float left = x - hitbox_length / 2;
    float right = x + hitbox_length / 2;
    float top = y - hitbox_width / 2;
    float bottom = y + hitbox_width / 2;
  
    // Draw lines for the hitbox
    stroke(0);
    line(left, top, right, top);      
    line(right, top, right, bottom);  
    line(right, bottom, left, bottom);
    line(left, bottom, left, top);
    noStroke();
  }
  
  // basic display for all entities
  public void display()
  {
    noStroke();
    rectMode(CENTER);
  }
}

// Interfaces Moveable and Display that all entities must implement
interface Moveable
{
  void move(float add_x, float add_y);
}

interface Display
{
  void display();
}
class Giant extends Boss
{
  // Giant constructor 
  Giant(float x, float y, float hitbox_length, float hitbox_width, float health ,float damage, float speed, float experience_drop, float score_increase, String name)
  {
    super(x, y, hitbox_length, hitbox_width, health, damage, speed, experience_drop, score_increase, name);
  }
  
  // Giant constructor with default values
  Giant()
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed, experience_drop, score_increase)
    super(random(width), random(height), 75, 75, 100, 100, 0.4f, 50, 300, "GIANT");
  }
  
  public void display()
  {
    super.display();
    fill(50, 200, 0);
    //circle(x, y, 75);
    
    imageMode(CENTER);
    if(facing_left)
    {
      image(giant_left_image, x, y, 75, 75);
    }
    else if(facing_right)
    {
      image(giant_right_image, x, y, 75, 75); 
    }
  }    
}
class Hit_Effect extends Effect
{
  // Initialize variables
  float speed;
  float angle;
  float rotation;

  Hit_Effect(float x, float y, int duration, float speed) 
  {
    super(x, y, duration);
    this.speed = speed;
    this.angle = random(TWO_PI);
    this.rotation = random(TWO_PI); 
  }

  // Display method for Hit Effect
  public void display() 
  {
    fill(255, 255, 0);
    pushMatrix();
    translate(x, y);
    rotate(rotation);
    // Update position based on angle and speed
    x += cos(angle) * speed;
    y += sin(angle) * speed;
    draw_star(0, 0, 8, 4, 5);
    popMatrix();
  }
}

// Method to draw star
 public void draw_star(float x, float y, float radius_1, float radius_2, int n_points) 
 {
  float angle = TWO_PI / n_points;
  float half_angle = angle / 2.0f;
  beginShape();
  for (float i = 0; i < TWO_PI; i += angle) 
  {
    float s_x = x + cos(i) * radius_2;
    float s_y = y + sin(i) * radius_2;
    vertex(s_x, s_y);
    s_x = x + cos(i + half_angle) * radius_1;
    s_y = y + sin(i +half_angle) * radius_1;
    vertex(s_x, s_y);
  }
  endShape(CLOSE);
}

// Method to start a new hit effect, spawn number of effects based on argument
public void start_hit_effect(float x, float y, int num_effects) 
{
  for (int i = 0; i < num_effects; i++) 
  {
    effects.add(new Hit_Effect(x, y, 250, 3));
  }
}
class Player extends Entity 
{
  // Initialize variables for Player class
  float max_health, proj_speed, firerate, regen, experience, max_experience, level, last_shot_time = 0, last_regen_time = 0;
  float speed_cap = 30, proj_speed_cap = 30, firerate_cap = 30;
  boolean moving_up, moving_down, moving_left, moving_right;

  // Player constructor 
  Player(float x, float y, float hitbox_length, float hitbox_width, float health, float max_health ,float damage, float speed, float proj_speed, float firerate, float regen, float experience, float max_experience, float level)
  {
    super(x, y, hitbox_length, hitbox_width, health, damage, speed);
    this.max_health = max_health;
    this.proj_speed = proj_speed;
    this.firerate = firerate;
    this.experience = experience;
    this.regen = regen;
    this.max_experience = max_experience;
    this.level = level;
  }

  // Player constructor with default values
  Player() 
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed)
    super(/*x*/ width / 2, /*y*/ height / 2, /*hitbox length*/ 20, /*hitbox width*/ 20, /*health*/ 10, /*damage*/ 1, /*speed*/ 1.5f);
    
    this.moving_up = false;
    this.moving_down = false;
    this.moving_left = false;
    this.moving_right = false;
    
    this.max_health = 10;
    this.proj_speed = 1;
    this.firerate = 1;
    this.regen = 0.25f;
    this.experience = 0;
    this.max_experience = 15;
    this.level = 1;
  }

  // keyPressed() method to determine if user is holding a movment keys 
  public void keyPressed() 
  {
    switch(key) 
    {
      case 'w':
        moving_up = true;
        break;
        
      case 'a':
        moving_left = true;
        break;
        
      case 's':
        moving_down = true;
        break;
        
      case 'd':
        moving_right = true;
        break;
    }
  }

  public void keyReleased() 
  {
    switch(key) 
    {
      case 'w':
        moving_up = false;
        break;
        
      case 'a':
        moving_left = false;
        break;
        
      case 's':
        moving_down = false;
        break;
        
      case 'd':
        moving_right = false;
        break;
    }
  }
  
  // spawn player projectile based on firerate 
  public void shoot() 
  {
    if(!is_paused)
    {
      // Calculate the cooldown period based on fire rate
      int current_time = millis();
      
      // Convert firerate from shots per second to milliseconds
      int cooldown = (int) (1000 / firerate);
      
      if (mousePressed && current_time - last_shot_time >= cooldown) 
      {
        // (x, y, hitbox_length, hitbox_width, health ,damage, speed) 
        player_projectiles.add(new Player_Projectile());
        
        // Update the time of the last shot
        last_shot_time = current_time;
      }
    }
  } 

  // check if the player can regenerate health, if so regen health
  public void check_regen() 
  {
    if (!is_paused && health < max_health) 
    {
      // Calculate the time elapsed since the last regen update
      int current_time = millis();
      float elapsed_time = current_time - last_regen_time;
      
      // Convert regen rate from health per second to milliseconds
      int regen_interval = (int) (1000 / regen);
  
      // If enough time has passed and not at max health for regen, update the health
      if (elapsed_time >= regen_interval) 
      {
        health += 1;
        last_regen_time = current_time;
      }
    } 
    else if (health >= max_health) 
    {
      // Reset the regen timer when health reaches max
      last_regen_time = millis();
    }
  }
  
  // check if players experience is equal or above max experience
  public boolean check_level_up() 
  {
    if (experience >= max_experience) 
    {
      player.level += 1;
      experience = 0;
      max_experience += 15;
      return true;
    }
    return false;
  }
  
  public String[] random_stat() 
  {
    String[] stats_array = {"MAX HEALTH", "DAMAGE", "SPEED", "PROJECTILE SPEED", "FIRERATE", "REGEN"};
    
    // Shuffle the array to ensure randomness
    for (int i = stats_array.length - 1; i > 0; i--) 
    {
      int index = (int) random(i + 1);
      // Swap elements at i and index
      String temp = stats_array[index];
      stats_array[index] = stats_array[i];
      stats_array[i] = temp;
    }
    
    // Create an array to store selected stats
    String[] selectedStats = new String[3]; 
    
    // Select the first three unique stats
    for (int i = 0; i < 3; i++) 
    {
      selectedStats[i] = stats_array[i];
    } 
    return selectedStats;
  }

  // level up stat
  public void increase_stat(String stat)
  {
    switch(stat) 
    {
      case "MAX HEALTH":
        max_health += 5;
        break;
        
      case "DAMAGE":
        damage += 0.5f;
        break;
        
      case "SPEED":
        if(speed < speed_cap)
        {
          speed += 0.5f;
        }
        break;
        
      case "PROJECTILE SPEED":
        if(proj_speed < proj_speed_cap)
        {
          proj_speed += 0.5f;
        }
        break;
        
       case "FIRERATE":
        if(firerate < firerate_cap)
        {
          firerate += 0.5f;
        }
        break;
        
      case "REGEN":
        regen += 0.25f;
        break;       
    }
  }
  
  public void reset_player() 
  {
    player = new Player
    (
      /*x*/ width / 2, 
      /*y*/ height / 2, 
      /*hitbox length*/ 20, 
      /*hitbox width*/ 20, 
      /*health*/ 10, 
      /*max_health*/ 10, 
      /*damage*/ 1, 
      /*speed*/ 1.5f, 
      /*proj_speed*/ 1, 
      /*firerate*/ 1, 
      /*regen*/ 0.5f, 
      /*experience*/ 0, 
      /*max_experience*/ 15, 
      /*level*/1
    );
  }
  
  // update the users position by using the move() method
  public void update() 
  {
    if(!is_paused)
    {
      float add_x = 0;
      float add_y = 0;
  
      if (moving_up && y - speed >= 0) 
      {
        add_y -= speed;
      }
      if (moving_down && y + speed <= height) 
      {
        add_y += speed;
      }
      if (moving_left && x - speed >= 0) 
      {
        add_x -= speed;
      }
      if (moving_right && x + speed <= width) 
      {
        add_x += speed;
      }
      
      // Normalize diagonal movement
      if (add_x != 0 && add_y != 0) 
      {
        float magnitude = sqrt(add_x * add_x + add_y * add_y);
        add_x = (add_x / magnitude) * speed;
        add_y = (add_y / magnitude) * speed;
      }
      move(add_x, add_y);
    }
  }
  
  // Display all stats of player
  public void display_stats()
  {
    fill(0);
    textSize(16);
    textAlign(LEFT);
    text("HEALTH: " + health + " / " + max_health + " (MAX \u221e)", 10, 20);
    text("DAMAGE: " + damage + " (MAX \u221e)", 10, 35);
    text("SPEED: " + speed + " (MAX " + speed_cap + ")", 10, 50);
    text("PROJ SPEED: " + proj_speed + " (MAX " + proj_speed_cap + ")", 10, 65);
    text("FIRERATE: " + firerate + " (MAX " + firerate_cap + ")", 10, 80);
    text("REGEN: " + regen + " (MAX \u221e)", 10, 95);
    text("EXPERIENCE: " + experience + " / " + max_experience + " (MAX \u221e)", 10, 110);
    text("LEVEL: " + level + " (MAX \u221e)", 10, 125);
    text("TOTAL DEFEATED: " + total_defeated + " (MAX \u221e)", 10, 140);
    text("TOTAL EXPERIENCE: " + total_experience + " (MAX \u221e)", 10, 155);
    text("DIFFICULTY: " + nf(difficulty, 0, 2) + " (MAX \u221e)", 10, 170);
    text("WAVE: " + wave + " (MAX \u221e)", 10, 185);
    
    text("P - PAUSE GAME", width - 115, 20);
    text("C - CLEAR SCENE", width - 115, 35);
    text("I - INVINCIBLE", width - 115, 50);
    text("H - TOGGLE HITBOXES", width - 115, 65);
    text("L - LEVEL UP", width - 115, 80);
    text("E - NO LEVELUP", width - 115, 95);
    text("M - MAX STATS", width - 115, 110);
    text("K - KILL PLAYER", width - 115, 125);
    text("R - RESET GAME", width - 115, 140);
    
    // Display health bar
    float health_percentage = 400 * (health / max_health);
    
    pushMatrix();
    rotate(PI);
    rectMode(CORNER);
    translate(-width + 10, -height + 10);
    fill(0);
    rect(0, 0, 20, 400);
    fill(255, 0, 0);
    rect(0, 0, 20, health_percentage);
    popMatrix();
    fill(255);
    textSize(25);
    textAlign(CENTER, CENTER);
    text((int)max_health, width - 20, height - 390);
    text("H\nE\nA\nL\nT\nH\n\n", width - 20, height - 200);
    text((int)health, width - 20, height - 30);
    
    // Display experience bar
    float experience_percentage = 450 * (experience / max_experience);
    
    pushMatrix();
    rectMode(CORNER);
    fill(0);
    rect(width / 2 - 225, 10, 450, 20);
    fill(128, 0, 128);
    rect(width / 2 - 225, 10, experience_percentage, 20);
    popMatrix();
    fill(255);
    textSize(20);
    textAlign(CENTER, CENTER);
    text((int)experience, width / 2 - 200, 20);
    text("LEVEL " + (int) level, width / 2, 20);
    text((int)max_experience, width / 2 + 200, 20);    
  }
  
  // display method to draw the players apperance
  public void display() 
  {
    super.display();
    fill(255, 0, 0);
    
    // Calculate angle between player and mouse
    float angle = atan2(mouseY - y, mouseX - x);
    
    // Adjust angle to align with sprite    
    // Add 90 degrees (PI/2 radians) to make the sprite face upwards
    angle += HALF_PI; 
    
    pushMatrix();
    translate(x, y);
    rotate(angle);  
    // Draw player image
    image(player_image, 0, 0, 40, 40); 
    popMatrix();
  }
}
class Player_Projectile extends Projectile
{
  PVector direction;
  
  // Basic_Projectile constructor
  Player_Projectile(float x, float y, float hitbox_length, float hitbox_width, float health ,float damage, float speed)
  {
    super(x, y, hitbox_length, hitbox_width, health, damage, speed);
    
    // Calculate direction vector from player to initial mouse click
    float dir_x = mouseX - x;
    float dir_y = mouseY - y;
    float magnitude = sqrt(dir_x * dir_x + dir_y * dir_y);
    direction = new PVector(dir_x / magnitude, dir_y / magnitude);
  }
  
  // Basic_Projectile constructor with default values
  Player_Projectile()
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed)
    this(player.x, player.y, 15, 15, 1, player.damage, player.proj_speed);
  }
  
  public void display()
  {
    super.display();
    fill(125);
    //circle(x, y, 10);
    image(player_projectile_image, x, y, 15, 15);
  }
  
  public void update() 
  {
    if(!is_paused)
    {
      float add_x = direction.x * speed;
      float add_y = direction.y * speed;
      
      move(add_x, add_y);
    }
  }
}
abstract class Projectile extends Entity 
{
  // Projectile constructor
  Projectile(float x, float y, float hitbox_length, float hitbox_width, float health, float damage, float speed) 
  {
    super(x, y, hitbox_length, hitbox_width, health, damage, speed);
  }

  // Projectile constructor with default values
  Projectile() 
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed)
    this(width / 2, height / 2, 5, 5, 1, 1, 1);
  }
}
class Speeder extends Enemy
{
  // Speeder constructor 
  Speeder(float x, float y, float hitbox_length, float hitbox_width, float health ,float damage, float speed, float experience_drop, float score_increase)
  {
    super(x, y, hitbox_length, hitbox_width, health, damage, speed, experience_drop, score_increase);
  }
  
  // Speeder constructor with default values
  Speeder()
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed, experience_drop, score_increase)
    super(random(width), random(height), 30, 50, 1, 2, 1.5f, 7, 25);
  }
  
  // Speeder constructor for boss_spawn_enemy();
    Speeder(float x, float y)
  {
    // (x, y, hitbox_length, hitbox_width, health ,damage, speed, experience_drop, score_increase)
    super(x, y, 30, 50, 1, 2, 1.5f, 0, 0);
  }
   
  public void display() 
  {
    super.display();
    fill(0, 100, 200);
    //circle(x, y, 25);
    
    imageMode(CENTER);
    if(facing_left)
    {
      image(speeder_left_image, x, y, 30, 50);
    }
    else if(facing_right)
    {
      image(speeder_right_image, x, y, 30, 50); 
    }
  }
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Simple_Rogue_Lite" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
